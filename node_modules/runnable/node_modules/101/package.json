{
  "name": "101",
  "version": "0.3.4",
  "description": "common javascript utils that can be required selectively that assume es5+",
  "main": "index.js",
  "scripts": {
    "test": "lab -c test",
    "test-watch": "nodemon --exec lab -c test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/tjmehta/101"
  },
  "keywords": [
    "utils",
    "js",
    "helpers",
    "functional",
    "pick",
    "pluck",
    "map",
    "array",
    "object",
    "string"
  ],
  "author": {
    "name": "Tejesh Mehta"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/tjmehta/101/issues"
  },
  "homepage": "https://github.com/tjmehta/101",
  "devDependencies": {
    "lab": "~3.0.1"
  },
  "dependencies": {
    "deep-eql": "^0.1.3",
    "keypather": "^1.6.0",
    "lab": "~3.1.1"
  },
  "readme": "101 [![Build Status](https://travis-ci.org/tjmehta/101.svg?branch=master)](https://travis-ci.org/tjmehta/101)\n===\n\ncommon utils that can be required selectively\n\n## and\n\nFunctional version of &&\n\n```js\nvar and = require('101/and');\n\nand(true, false); // false\nand(true, true);  // true\n```\n\n## apply\n\nFunctional version of function.apply\n\n```js\nvar apply = require('101/apply');\n\nand(true, false); // false\nand(true, true);  // true\n```\n\n## exists\n\nSimple exists function\n\n```js\nvar exists = require('101/exists');\n\nexists('foo');     // true\nexists(null);      // false\nexists(undefined); // false\n```\n\n## findIndex\n\nJust like ES6's array.findIndex\n\nFinds the first value in the list that passes the given function (predicate) and returns it's index.\nIf list is not provided findIndex will return a partial-function which accepts a list as the first argument.\n\n```js\nvar findIndex = require('101/find-index');\nvar arr = [1, 2, 3];\n\nvar index = findIndex(arr, function (val, i, arr) {\n  return val === 2;\n});\n// returns 1\n// returns -1 if not found\n```\n\n## hasKeypaths\n\nDetermines whether the keypaths exist and have the specified values.\n\n```js\nvar hasKeypaths = require('101/has-keypaths');\nvar obj = {\n  foo: {\n    bar: {\n      qux: 1\n    }\n  }\n};\n\nhasKeypaths(obj, ['foo.bar.qux']);      // true\nhasKeypaths(obj, { 'foo.bar.qux': 1 }); // true\nhasKeypaths(obj, ['foo.qux']);          // false\nhasKeypaths(obj, { 'foo.bar': 2 });     // false\nhasKeypaths(obj, { 'foo.bar': 1, 'nope': 1 }); // false\n\n// optional 'deep' arg, defaults to true\nvar barObj = { bar: 1 };\nhasKeypaths(obj, { 'foo.bar': barObj });         // true\nhasKeypaths(obj, { 'foo.bar': barObj }, true);   // true\nhasKeypaths(obj, { 'foo.bar': barObj }, false);  // false\nhasKeypaths(obj, { 'foo.bar': obj.foo }, false); // true\nhasKeypaths(obj, ['foo.bar'], false);            // true, uses [hasOwnProperty vs in](http://stackoverflow.com/questions/13632999/if-key-in-object-or-ifobject-hasownpropertykey)\n```\n\n## hasProperties\n\nDetermines whether the keys exist and, if specified, has the values.\n\n```js\nvar hasProperties = require('101/has-properties');\nvar obj = {\n  foo: {\n    bar: 1\n  },\n  qux: 1\n};\n\nhasProperties(obj, ['foo', 'qux']); // true\nhasProperties(obj, { qux: 1 }) // true\n\n// optional 'deep' arg, defaults to true\nvar barObj = { bar: 1 };\nhasProperties(obj, { 'foo.bar': barObj });         // true\nhasProperties(obj, { 'foo.bar': barObj }, true);   // true\nhasProperties(obj, { 'foo.bar': barObj }, false);  // false\nhasProperties(obj, ['foo.bar'], false);            // true, uses [hasOwnProperty vs in](http://stackoverflow.com/questions/13632999/if-key-in-object-or-ifobject-hasownpropertykey)\n```\n\n## instanceOf\n\nFunctional version of JavaScript's instanceof, returns a\npartial function which expects a value argument and returns\n\n```js\nvar instanceOf = require('101/instance-of');\n\n['foo', 'bar', 1].map(instanceOf('string')); // [true, true, false]\n```\n\n## isBoolean\n\nFunctional version of val typeof 'boolean'\n\n```js\nvar isBoolean = require('101/is-boolean');\n\n[true, false, 1].map(isBoolean); // [true, true, false]\n```\n\n## isFunction\n\nFunctional version of val typeof 'function'\n\n```js\nvar isFunction = require('101/is-function');\n\n[parseInt, function () {}, 'foo'].map(isFunction); // [true, true, false]\n```\n\n## isObject\n\nFunctional *strict* version of val typeof 'object' (and not array or regexp)\n\n```js\nvar isObject = require('101/is-object');\n\n[{}, { foo: 1 }, 100].map(isObject); // [true, true, false]\n```\n\n## isString\n\nFunctional version of val typeof 'string'\n\n```js\nvar isObject = require('101/is-object');\n\n[{}, { foo: 1 }, 100].map(isObject); // [true, true, false]\n```\n\n## last\n\nReturns the last value of the item.\n\n```js\nvar last = require('101/last');\n\nlast([1, 2, 3]); // 3\nlast('hello');   // 'o'\nlast({\n  foo: 1,\n  bar: 2\n});              // 2\n```\n\n## not\n\nFunctional version of !\n\n```js\nvar not = require('101/not');\n\nnot(isString)('hey'); // false\nnot(isString)(100);   // true\n```\n\n## or\n\nFunctional version of ||\n\n```js\nvar or = require('101/or');\n\nor(true, true);   // true\nor(true, false);  // true\nor(false, false); // false\n```\n\n## passAll\n\nMuxes arguments across many functions and &&'s the results\n\n```js\nvar passAll = require('101/pass-all');\n\n['', 'foo', 'bar', 100].map(passAll(isString, isTruthy)); // [false, true, true, false]\n```\n\n## passAny\n\nMuxes arguments across many functions and ||'s the results\n\n```js\nvar passAny = require('101/pass-any');\n\n['', 'foo', 'bar', 100].map(passAny(isString, isNumber)); // [true, true, true, true]\n```\n\n## pick\n\nReturns a new object with the specified keys (with key values from obj)\n\n```js\nvar pick = require('101/pick');\nvar obj = {\n  foo: 1,\n  bar: 2\n};\n\npick(obj, 'foo');          // { foo: 1 }\npick(obj, ['foo']);        // { foo: 1 }\npick(obj, ['foo', 'bar']); // { foo: 1, bar: 2 }\n\n// use it with array.map\n[obj, obj, obj].map(pick('foo')); // [{ foo: 1 }, { foo: 1 }, { foo: 1 }];\n```\n\n## pluck\n\nFunctional version of obj[key], returns the value of the key from obj.\n\n```js\nvar pluck = require('101/pluck');\nvar obj = {\n  foo: 1,\n  bar: 2\n};\n\npluck(obj, 'foo'); // 1\n\n// use it with array.map\n[obj, obj, obj].map(pluck('foo')); // [1, 1, 1]\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "_id": "101@0.3.4",
  "_from": "101@~0.3.2"
}
