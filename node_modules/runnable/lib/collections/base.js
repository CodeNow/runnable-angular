'use strict';
var isFunction = require('101/is-function');
var exists = require('101/exists');
var pathJoin = require('../url-join');
var modelStore = require('../stores/model-store');

module.exports = Collection;

function Collection (models, opts) {
  this.add(models);
  this.opts = opts || {};
  if (!opts.client) {
    throw new TypeError('collection requires a client');
  }
  if (!this.Model) {
    throw new TypeError('collection requires a Model'); // optional urlPath
  }
  if (this.opts.parentPath) {
    this.urlPath = pathJoin(this.opts.parentPath, this.urlPath);
  }
  this.qs = opts.qs || {};
  this.client = this.opts.client;
  Array.call(this);
}

// inherit from array
var arrayMethods = [];
for (var method in Array.prototype) {
  if (Array.prototype.hasOwnProperty(method)) {// array methods only
    arrayMethods.push(method);
  }
}
arrayMethods.forEach(function (method) {
  Collection.prototype[method] = function () {
    var models = this.models;
    return models[method].apply(models, arguments);
  };
});

Collection.prototype.reset = function (data) {
  this.models.splice(0, this.models.length);
  this.add(data);
  return this;
};

Collection.prototype.add = function (data) {
  var self = this;
  this.models = this.models || [];

  var models = data.map(function (model) {
    var isModel = (model instanceof self.Model);
    if (!isModel) {
      model = new self.Model(model, self.opts);
      model = modelStore.check(model);
    }
    return model;
  });
  this.models = this.models.concat(models);
  return this;
};

Collection.prototype.path = function () {
  return this.urlPath || this.Model.prototype.urlPath;
};

Collection.prototype.fetch = function (opts, cb) {
  if (isFunction(opts)) {
    cb = opts;
    opts = null;
  }
  var self = this;
  opts = opts || { qs: this.query() };
  opts = opts.qs || opts.headers ?
    opts : { qs: opts }; // assume opts are qs if no qs key
  opts.statusCodes = opts.statusCodes || {
    200: true,
    400: false,
    401: false,
    404: false
  };
  this.query(opts.qs);
  return this.client.get(this.path(), opts, function (err, body, code) {
    if (err) {
      cb(err);
    }
    else if (!Array.isArray(body)) {
      err = new Error(self.constructor.name+' (collection) fetch received a non-array response');
      err.body = body;
      cb(err);
    }
    else {
      self.reset(body);
      cb(null, body, code);
    }
  });
};

Collection.prototype.toJSON = function () {
  return this.models.map(function (model) {
    return model.toJSON();
  });
};

Collection.prototype.query = function (qs) {
  if (exists(qs)) {
    this.qs = qs || {};
  }
  return this.qs;
};