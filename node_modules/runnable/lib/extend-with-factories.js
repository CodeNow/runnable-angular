'use strict';

var debug = require('debug')('runnable-api-client');
var fs = require('fs');
var path = require('path');
var fsUtils = require('./fs-utils');
var exists = require('101/exists');
var isFunction = require('101/is-function');
var isString = require('101/is-string');
var extend = require('xtend');
var modelStore = require('./stores/model-store');
var collectionStore = require('./stores/collection-store');
var fullPath = fsUtils.fullPath;
var isFile = fsUtils.isFile;
var isDir = fsUtils.isDir;
var isBrowser = typeof window !== 'undefined' || process.env.NODE_ENV === 'browser';

var browserFsCacheFile = 'browser-fs-cache.js';

module.exports = function (Class, location) {
  location = exists(location) ? location : Class.name.toLowerCase();
  var collectionsDir = path.resolve(__dirname, 'collections', location);
  debug('collectionsDir: ' + collectionsDir);
  var collections = dirFiles(collectionsDir);

  var modelsDir = path.resolve(__dirname, 'models', location);
  debug('modelsDir: ' + modelsDir);
  var models = dirFiles(modelsDir);

  // fetch[Collection]
  collections.forEach(function (Collection) {
    var collectionName = Collection.name;
    if (collectionName === 'Base') {
      return; // skip
    }
    Class.prototype['fetch'+collectionName] = function (opts, cb) {
      var collection = new Collection([], {
        client: this.opts.client,
        parentPath: location ? this.path() : '',
        qs: opts.qs
      });
      collection = collectionStore.check(collection);
      collection.fetch(opts, cb);
      return collection;
    };
  });

  // create[Model](opts, cb)
  // fetch[Model](id, opts, cb)
  // update[Model](id, opts, cb)
  // destroy[Model](id, opts, cb)
  models.forEach(function (Model) {
    var modelName = Model.name;
    if (modelName === 'Base') {
      return; // skip
    }
    Class.prototype['new'+modelName] = function (attrs, opts) {
      attrs = attrs || {};
      opts = opts || {};
      opts = extend(opts, {
        client: this.opts.client,
        parentPath: location ? this.path() : ''
      });
      var model = new Model(attrs, opts);
      if (!model.id()) {
        console.error('warning: it is dangerous to create models without an id, '+
          'bc you may be creating a duplicate instance of the same model');
      }
      return modelStore.get(model) || model;
    };
    Class.prototype['create'+modelName] = function (opts, cb) {
      var model = new Model({}, {
        client: this.opts.client,
        parentPath: location ? this.path() : ''
      });
      model.create(opts, function (err) {
        if (!err) {
          modelStore.check(model);
        }
        cb.apply(null, arguments);
      });
      return model;
    };
    var actions = ['fetch', 'update', 'destroy'];
    actions.forEach(function (action) {
      Class.prototype[action+modelName] = function (id, opts, cb) {
        if (!isString(id)) {
          var err = new TypeError(action+modelName+': id is required');
          var args = (new Model()).formatArgs(arguments); //using format args to find cb
          if (args.cb) {
            args.cb(err);
          }
          else {
            throw err;
          }
        }
        var model = new Model(id, {
          client: this.opts.client,
          parentPath: location ? this.path() : ''
        });
        model = modelStore.check(model);
        model[action](opts, cb);
        return model;
      };
    });
    Object.keys(Model.prototype).forEach(function (method) {
      if (isFunction(Model.prototype[method]) && !isFactoryMethod(method)) {
        Class.prototype[method+modelName] = function (id, opts, cb) {
          var model =  new Model(id, {
            client: this.opts.client,
            parentPath: location ? this.path() : ''
          });
          model = modelStore.check(model);
          model[method].call(model, opts, cb);
          return model;
        };
      }
    });
  });
};

function isFactoryMethod (name) {
  var actions = ['create', 'fetch', 'update', 'destroy'];
  return actions.some(startsButNotEqual(name));
}

function startsButNotEqual (str) {
  return function (start) {
    return str.indexOf(start) === 0 && start.length !== str.length;
  };
}

var buildCache = {};
function dirFiles (dirpath) {
  var models;
  if (isBrowser) {
    var browserFsCache = require('./browser-fs-cache');
    models = browserFsCache[path.relative(__dirname, dirpath)]();
  }
  else {
    var filepaths = !isDir(dirpath) ? [] :
      fs.readdirSync(dirpath)
        .map(fullPath(dirpath))
        .filter(isFile);
    buildCache[path.relative(__dirname, dirpath)] = filepaths.map(function (filepath) {
      return '.'+path.join('/', path.relative(__dirname, filepath));
    });
    models = filepaths.map(function (filepath) {
      return require(filepath);
    });

    createBrowserFsCache();
  }
  return models;
}

var buildPrintTimeout;
function createBrowserFsCache () {
  clearTimeout(buildPrintTimeout);
  buildPrintTimeout = setTimeout(function () {
    var browserFsCacheContent = 'module.exports = {\n';

    Object.keys(buildCache).forEach(function (parentModelPath) {
      var requirePaths = buildCache[parentModelPath];
      browserFsCacheContent += [
        '\t', JSON.stringify(parentModelPath),
        ': ',
        'function () {\n\t\treturn '+requirePaths.reduce(toRequireArrStr, '[]')+';\n\t}',
        ',\n'
      ].join('');
      function toRequireArrStr (requireArrStr, requirePath, i) {
        if (i === 0) {
          requireArrStr = '[ ';
        }
        requireArrStr += ['require(', JSON.stringify(requirePath), ')'].join('');
        if (i < requirePaths.length-1) {
          requireArrStr += ', ';
        }
        else {
          requireArrStr += ' ]';
        }
        return requireArrStr;
      }
    });
    browserFsCacheContent += '};';
    fs.writeFileSync(path.join(__dirname, browserFsCacheFile), browserFsCacheContent);
    if (process.env.NODE_ENV === 'build') {
      console.log(
        path.join(__dirname, browserFsCacheFile)+'\n',
        browserFsCacheContent);
    }
  }, 10);
}